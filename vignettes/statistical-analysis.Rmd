---
title: "Statistical Analysis with tidymatrix"
author: "tidymatrix package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Statistical Analysis with tidymatrix}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5
)
```

This vignette demonstrates how to perform PCA, clustering, and other statistical analyses on tidymatrix objects.

```{r load-packages}
library(tidymatrix)
library(dplyr)
```

## Creating Example Data

We'll use simulated gene expression data with clear biological structure:

```{r create-data}
set.seed(42)
n_genes <- 100
n_samples <- 20

# Simulate expression matrix
expression <- matrix(rnorm(n_genes * n_samples), nrow = n_genes, ncol = n_samples)

# Add structure: genes in groups, samples in conditions
expression[1:30, 1:10] <- expression[1:30, 1:10] + 2  # Group 1 genes high in Control
expression[31:60, 11:20] <- expression[31:60, 11:20] + 2  # Group 2 genes high in Treatment

# Create metadata
gene_data <- data.frame(
  gene_id = paste0("Gene_", 1:n_genes),
  chromosome = sample(paste0("chr", 1:5), n_genes, replace = TRUE)
)

sample_data <- data.frame(
  sample_id = paste0("Sample_", 1:n_samples),
  condition = rep(c("Control", "Treatment"), each = 10),
  batch = rep(1:2, 10)
)

# Create tidymatrix
expr_tm <- tidymatrix(expression, gene_data, sample_data)
```

## Principal Component Analysis (PCA)

### PCA on Samples

```{r pca-samples}
expr_tm <- expr_tm |>
  activate(columns) |>
  compute_prcomp(name = "sample_pca", center = TRUE, scale. = TRUE)

# Check columns added to sample metadata
names(expr_tm$col_data)

# Get the full PCA object
pca_obj <- get_analysis(expr_tm, "sample_pca")
var_explained <- pca_obj$sdev[1:3]^2 / sum(pca_obj$sdev^2) * 100
cat("Variance explained by first 3 PCs:\n")
print(round(var_explained, 2))
```

### Using PC Scores

```{r use-pca}
# Find samples with high PC1 scores
high_pc1 <- expr_tm |>
  activate(columns) |>
  filter(sample_pca_PC1 > median(sample_pca_PC1)) |>
  pull(sample_id)

cat("Samples with high PC1 scores:\n")
print(high_pc1)
```

## Hierarchical Clustering

### Clustering Genes

```{r cluster-genes}
expr_tm <- expr_tm |>
  activate(rows) |>
  compute_hclust(k = 3, name = "gene_clusters", method = "ward.D2")

# Count genes per cluster
cluster_counts <- expr_tm |>
  activate(rows) |>
  count(gene_clusters_cluster)

print(cluster_counts$row_data)
```

### Accessing Dendrogram

```{r dendrogram}
# Get the dendrogram for plotting
hc_obj <- get_analysis(expr_tm, "gene_clusters")
cat("Dendrogram height:", round(max(hc_obj$height), 2), "\n")
```

## Multiple Clusterings

You can perform multiple clusterings with different parameters:

```{r multiple-clusters}
expr_tm <- expr_tm |>
  activate(rows) |>
  compute_hclust(k = 5, name = "gene_k5") |>
  compute_kmeans(centers = 4, name = "gene_km4", nstart = 25)

# List all stored analyses
cat("Stored analyses:\n")
print(list_analyses(expr_tm))
```

### Comparing Clusterings

```{r compare-clusters}
# Compare different clustering results
comparison <- expr_tm |>
  activate(rows) |>
  count(gene_clusters_cluster, gene_k5_cluster)

head(comparison$row_data, 10)
```

## Analysis Invalidation

When you filter or subset the data, stored analysis objects are automatically removed to prevent mismatches:

```{r invalidation}
cat("Analyses before filtering:\n")
print(list_analyses(expr_tm))

cat("\nNumber of rows before filter:", nrow(expr_tm$matrix), "\n")

# Filter to high-variance genes
expr_tm_filtered <- expr_tm |>
  activate(rows) |>
  mutate(gene_var = apply(expr_tm$matrix, 1, var)) |>
  filter(gene_var > median(gene_var))

cat("Number of rows after filter:", nrow(expr_tm_filtered$matrix), "\n")

cat("\nAnalyses after filtering:\n")
print(list_analyses(expr_tm_filtered))

cat("\nNote: Metadata columns are preserved:\n")
cat("Cluster columns still present:",
    "gene_clusters_cluster" %in% names(expr_tm_filtered$row_data), "\n")
```

## Complex Workflows

Chain multiple analyses together:

```{r complex-workflow}
# Complete analysis workflow
workflow_tm <- tidymatrix(expression, gene_data, sample_data) |>
  # PCA on samples
  activate(columns) |>
  compute_prcomp(name = "samples", center = TRUE, scale. = TRUE) |>
  # Cluster samples
  compute_hclust(k = 2, name = "sample_groups") |>
  # Cluster genes
  activate(rows) |>
  compute_hclust(k = 5, name = "gene_modules", method = "ward.D2") |>
  # Add variance as a feature
  mutate(variance = apply(expression, 1, var))

# Complex queries
cat("\nGenes in module 1 with high variance:\n")
result <- workflow_tm |>
  activate(rows) |>
  filter(gene_modules_cluster == 1, variance > quantile(variance, 0.75))

cat("Found", nrow(result$matrix), "genes\n")

# Check sample grouping
cat("\nSample grouping:\n")
sample_groups <- workflow_tm |>
  activate(columns) |>
  count(sample_groups_cluster, condition)

print(sample_groups$col_data)
```

## Summary

The tidymatrix package provides:

- **PCA**: `compute_prcomp()` for dimensionality reduction
- **Hierarchical clustering**: `compute_hclust()` with customizable methods
- **K-means clustering**: `compute_kmeans()` for partitioning
- **Analysis storage**: Retrieve full objects with `get_analysis()`
- **Safe operations**: Analysis invalidation prevents data-metadata mismatches

All analyses integrate seamlessly with dplyr operations for powerful data exploration.
